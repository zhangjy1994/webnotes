# 面试题汇总
## 事件是如何实现的？
## new 一个函数发生了什么？
  1. 创建一个新的空对象
  2. 设置新对象的__proto__属性继承构造函数的原型对象
  3. 用新对象调用构造函数，将构造函数的this，临时替换为新对象，构造函数会向新对象中添加新成员
  4. 返回新对象的地址保存到变量中
## 函数作用域在定义时确定而不是执行时
``` js
var x = 10
function a(y) {
  var x = 20
  return b(y)
}
function b(y) {
  return x + y
}
console.log(a(20))
```
## js事件执行机制
> 主线程-微任务-宏任务
``` js
async function async1() {
  console.log('async1 start');
  await async2()
  console.log('async1 end');
  
}
async function async2() {
  new Promise(function (resolve) {
    console.log('promise1');
    resolve()
    
  }).then(function () {
    console.log('promise2');
  })
}

console.log('script Start');
setTimeout(function() {
  console.log('setTimeout');
},0)

async1()

new Promise(function(resolve) {
  console.log('promise3');
  resolve()
  
}).then(function() {
  console.log('promise4');
})
console.log('script end');

// 执行结果
// 主线程
script start
async1 start
promise1
promise3
scirpt end
// 微任务
promise2
async1 end
promise4
// 宏任务
setTimeout
// end
```
## call,bind,apply
>全局变量：window的属性(通过var声明)

>全局函数：window的方法
#### 1.call()/apply()/bind()区别
* call(obj)/apply(obj)：调用函数，指定函数中的this为第一个参数的值
* bind(obj)：返回一个新的函数，新函数内部会调用原来的函数，且this为bind()指定的第一参数的值
* 注意：如果obj是null/undefined，this为window

``` js
function fn(a, b) {
  this.x = 3
  console.log(a, b, this, arguments.length)
}
fn(1, 2)
console.log(x)
const obj = {m: 0}

fn.call(obj, 1, 2)
fn.apply(obj, [1, 2])
fn.call(undefined, 1, 2)
fn.call(null, 1, 2)
fn.bind(obj)(3, 4)
fn.bind(obj, 5)(3, 4)
fn.bind(obj, 5, 6)(3, 4)
```

#### 2.应用
* call()/bind()应用：根据伪数组生成真数组
* bind()：react中组件的自定义方法 / vue中的事件回调函数内部

#### 3.自定义call()/apply()
a. 给obj添加一个临时方法，方法名任意，值为当前函数  
b. 通过obj调用这个临时方法，并将接收的参数传入  
c. 删除obj上的这个临时方法属性

::: details 点击查看代码（简单版）
``` js
// 简单
Function.prototype.call = function (obj, ...args) {
  // call 
  // 处理obj是undefined或者null的情况
  if (obj === undefined || obj === null) {
    obj = window
  }
  // 给obj添加一个方法：tempFn=>this
  obj.tempFn = this
  // 调用obj的tempFn方法，传入args参数，得到返回值
  const result = obj.tempFn(...args)
  // 删除obj上的tempFn
  delete obj.tempFn
  // 返回方法的返回值
  return result
}
Function.prototype.apply = function (obj, args) {
  // apply 
  // 处理obj是undefined或者null的情况
  if (obj === undefined || obj === null) {
    obj = window
  }
  // 给obj添加一个方法：tempFn=>this
  obj.tempFn = this
  // 调用obj的tempFn方法，传入args参数，得到返回值
  const result = obj.tempFn(...args)
  // 删除obj上的tempFn
  delete obj.tempFn
  // 返回方法的返回值
  return result
}
```
:::

``` js
// call
Function.prototype.call = function (context, ...args) {
  context = context || window;
  
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  context[fnSymbol](...args);
  delete context[fnSymbol];
}

// apply
Function.prototype.apply = function (context, argsArr) {
  context = context || window;
  
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  context[fnSymbol](...argsArr);
  delete context[fnSymbol];
}

```

#### 4.自定义实现bind()
a. 返回一个新函数  
b. (1) 在新函数内部通过原函数对象的call方法来执行原函数  
  &ensp;&ensp;(2) 指定this为obj  
  &ensp;&ensp;(3) 指定参数为bind调用的参数和后面新函数调用的参数

::: details 点击查看代码（简单版）
``` js
Function.prototype.bind = function (obj, ...args) {
  // 返回一个新函数
  return (...arg2) => {
    // 调用原来的函数，指定this为obj，参数列表有args和args2一次组成
    return this.call(obj, ...args, ...args2)
  }
}
```
:::

``` js
// bind
Function.prototype.bind = function (context, ...args) {
  context = context || window;
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  
  return function (..._args) {
    args = args.concat(_args);
    
    context[fnSymbol](...args);
    delete context[fnSymbol];   
  }
}

```

## js中break，continue，return 的区别
> break：结束循环推荐使用

> return：直接跳出方法
* break:  
break语句会使运行的程序立刻退出包含在最内层的循环或者退出一个switch语句。  
由于它是用来退出循环或者switch语句，所以只有当它出现在这些语句时，这种形式的break语句才是合法的。
``` js
for(var i = 1; i < 10; i++) {
  if (i === 8) {
    break
  }
  document.write(i)
}
// 当i === 8的时候，直接退出for这个循环。这个循环将不再被执行！
// 输出结果：1234567
```
* continue:  
continue语句和break语句相似。所不同的是，它不是退出一个循环，而是开始循环的一次新迭代。  
continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内，在其它地方使用都会引起错误。
``` js
for(var i = 1; i < 10; i++) {
  if (i === 8) {
    continue
  }
  document.write(i)
}
// 当i === 8的时候，直接跳出本次for循环。下次继续执行！
// 输出结果：1234567910
```
* break:  
return语句就是用于指定函数返回的值。  
return语句只能出现在函数体内，出现在代码中的其他任何地方都会造成语法错误，当执行return语句时，即使函数主体中还有其他语句，函数执行也会停止。
``` js
for(var i = 1; i < 10; i++) {
  if (i === 8) {
    return
  }
  document.write(i)
}
// 执行结果：Uncaught SyntaxError: Illegal return statement
```