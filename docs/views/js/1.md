# js基础知识
## 概述
* 什么是Javascript?
  + 运行于JS解释器/引擎中的解释型脚本语言
  + 解释型：执行时才检查错误
  + 脚本语言：只有在运行的时候才会被编译或解释的语言
## 数据类型
* 基本类型：Number、Boolean、String、null、undefined、symbol(ES6)、BigInt(ES2020)
* 引用类型：Object => 对象子类型(Array, Function)
## 内置对象
* ES标准中规定的，浏览器厂商已经实现的内置类型: 11个
  + Number、String、Boolean——包装类型:专门封装基本类型的值，并提供操作基本类型的值得方法的对象
  + Array、RegExp、Date、Math
  + Error
  + Function、Object
  + Global(在浏览器中被window取代)
## 错误对象
  Error: 6种
  + SyntaxError
  + ReferenceError
  + TypeError
  + RangeError
  + URIError
  + EvalError
## 数组api
* join()
* concat()
* slice(starti, endi)
* reverse()
* splice()
  + 删除：arr.splice(starti, n)=> n指个数
  + 插入：arr.splice(starti, 0, 值1, 值2, ...)
  + 替换: arr.splice(starti, n, 值1, 值2, ...)
* sort()
  + 将arr中的元素按升序排列
  + 默认将所有元素转换为字符串再排列：js中的数组不限制元素的类型，为了保证sort方法正常执行，默认将所有元素转为字符串，再比较unicode。所以，默认的sort方法，只能排序字符串元素。
  + 如果排序非字符串类型的元素: 2步:
    1. 自定义比较器函数(专门比较两个值大小的函数)
      >专门比较两个数字大小的比较器：function compare(a,b){return a-b}

      >专门比较两个字符串长度的比较器：function compare(a,b){return a.length-b.length}
    2. 将比较器函数传入sort方法作为比较大小的依据。
      >arr.sort(compare)
* push()=>结尾入栈
* pop()=>结尾出栈
* unshift()=>开头入栈
* shift()=>开头出栈
* Array.isArray(arr)
* every()
* some()
* forEach()
* map()
* filter()
* reduce()
## String api  
  所有String API都无权修改原字符串，只能返回新字符串，所以都要用变量接住。
* toUpperCase()
* toLowerCase()
* charAt(i) => str[i]
* charCodeAt(i)
* indexOf('关键字', fromi)
* lastIndexOf('关键字', fromi)
* search(/正则表达式/i)
* match(/正则表达式/ig)
* replace(/正则表达式/ig, '替换值')
::: details replace Demo
``` js
//将英文句子中每个单词首字母改大写
var str="you can you up";
str=str.replace(/\b([a-z])([a-z]*)\b/ig,
  function(kw,$1,$2){
    return $1.toUpperCase()+$2;
  }
)
console.log(str);//You Can You Up
```
:::
* split(/正则表达式/)
* concat()
* slice(starti, endi)
* subString(starti, endi) 不支持负数参数
* subStr(starti, n) 从starti位置开始截取n个字符

## 正则表达式
* 字符集: 规定一位字符可用的备选字符列表=>[字符列表]
  + 所有字符连续排列，不需要分割
  + 一个字符集，只能修饰一位字符
  + 一个字符集中必须且只能选一个
  + 简写: 如果字符集太长，且连续，用-省略中间的字符:
    - 1位字母：[A-Za-z]
    - 1位数字：[0-9]
    - 1位汉字：[\u4e00-\u9fa5]
    - 除了4和7：[^47]
* 预定义字符集
  + 1位数字：\d => [0-9]
  + 1位数字、字母、_：\w => [0-9A-Za-z_]
  + 1位控制符：\s => 空格、换行、Tab
  + 1位任意字符：.
* 量词：固定一个字符集出现次数的规则
  1. 有明确数量边界的
    - 字符集{m,n} 字符集最少m个，最多n个
    - 字符集{m,} m个以上
    - 字符集{m} 必须m个
  2. 没有明确数量边界的
    - 字符集? 可有可无，最多1个
    - 字符集* 可有可无，个数不限
    - 字符集+ 至少1个，多了不限
* 选择和分组
  - 选择：规则1|规则2
  - 分组：将一组规则，用()包裹
* 指定匹配位置
  - ^ 匹配字符串开头  
    比如: 匹配开头的空字符: ^\s+
  - $ 匹配字符串结尾  
    比如: 匹配结尾的空字符: \s+$
  - \b 匹配单词边界
* api
  - var arr = reg.exec(str) 即找每个关键词的内容，又获得每个关键词的位置。如果找所有，要用循环推动
  ::: details reg.exec() Demo
  ``` js
  var names=["明明", "静静"];
  var reg=new RegExp(names.join("|"),"g");
  var str="明明喜欢我，却不告诉我"+
          "别理我，我想静静"+
          "静静是谁?"+
          "你先告诉我明明是谁"+
          "窗前明月光"+
          "一行白鹭上青天";
  var arr=null;
  //只要arr不是null
  while((arr=reg.exec(str))!=null){
    console.log(
      "在位置 "+arr.index+
      " 发现敏感词: "+arr[0]+
      " 下次从"+reg.lastIndex+"开始");
  }
  // 在位置 0 发现敏感词: 明明 下次从2开始
  // 在位置 17 发现敏感词: 静静 下次从19开始
  // 在位置 19 发现敏感词: 静静 下次从21开始
  // 在位置 29 发现敏感词: 明明 下次从31开始
  ```
  :::
  - var bool = reg.test(str)
## this指向
  #### this: 指代正在调用方法的对象(.前的对象)
  * obj.method() //method中的this->obj
  * 如果一个函数，没有用任何对象调用，其中this默认指window  
    method(); //method中的this->window
  * 匿名函数自调: 匿名函数内的this->window
  * 回调函数:
  ``` js
  arr.sort(function(){
     this->window
  })
  arr.forEach(function(val){
     this->window
  })
  setInterval(function(){
     this->window
  },ms);
  ``` 
  * 特例：jquery中
  ``` js
  $(selector).each(function(){
     this->当前DOM元素
  })
  ```
  * 事件处理函数: **this->绑定事件的元素对象**
  * 如果this不是想要的:
    - 需要立刻执行的函数: call/apply临时替换this
    - 替换回调函数中的this: bind 永久替换

## OOP、原型对象、构造函数
  * 原型对象(prototype)：集中保存所有子对象共有成员的父级对象
    + 如何获得：
      - 构造函数.prototype
      - 子对象.__proto__(内部属性)
      - Object.getPrototypeOf(obj) -> 获得obj对象的父级原型对象
  * 原型链
    + 由各级对象的__proto__属性，逐级继承，形成的链式结构
  * 对象的calss属性
    + 对象的内部属性，记录创建对象时使用的类型名
    + 只有一个办法获得对象的class：Object.prototype.toString() -> [object Object](对象 class)
      - 问题: 数组类型等内置类型，纷纷重写了toString方法，直接调用数组对象的方法，不再返回class属性值。
      - call强行借用一个函数，并临时替换函数中的this为指定对象 -> Object.prototype.toString.call(obj)
  * 判断继承关系
    1. 根据原型对象判断
        + father.isPrototypeOf(child) -> 判断father是否是child的父级对象;判断child是否继承自father；不仅检查直接父对象，而且检查整个原型链。
    2. 根据构造函数判断
        + child instanceof 构造函数 -> 判断child是否是构造函数创建出的实例；不仅检查直接父对象，而且检查整个原型链。
  * 修改继承
    1. 每次只能修改一个对象的父对象
        + child.__proto__ = father -> 等同于：Object.setPrototypeOf(child, father)
    2. 批量修改所有子对象的父对象
        + 构造函数.prototype = father -> 强调: 必须在开始创建对象之前就修改。
    3. 两种类型间的继承
        + 定义公共父类型，集中定义子类型有用的属性和方法
        + 让子类型的原型对象继承父类型的原型对象——子对象可使用公共父类型中的共有方法。——inherits  
            Object.setPrototypeOf(  
              子类型构造函数.prototype,  
              父类型构造函数.prototype  
	          )  
            >inherits继承: 直接使用父对象中的成员
        + 在子类型构造函数中借用父类型构造函数——extends  
          父类型构造函数.call(this,属性参数)  
          父类型构造函数.apply(this,arguments)  
          >extends扩展: 为子对象扩展父类型没有的属性
    ``` js
    //定义父类型构造:
    function Flyer(name,speed){
      this.name=name;
      this.speed=speed;
    }
    Flyer.prototype={
      fly:function(){
        console.log(
          this.name+"以时速"+this.speed+"飞行"
        )
      }
    }
    //定义Plane类型描述敌机
      //包括3个属性: name,speed,score
    function Plane(name,speed,score){
      //先借用父类型构造函数
      Flyer.apply(this,arguments);
        //=>Flyer(name,speed)//this->f16
      //this->如果一个方法没有用new或任何对象调用,则其中的this，默认为window
      this.score=score;
    }
    //在Plane的原型对象中添加fly方法
      //输出: "name以时速speed飞行"
    //在Plane的原型对象中添加getScore方法
      //输出: "击落敌机，得score分"
    Plane.prototype={
      getScore:function(){
        console.log(
          "击落敌机，得"+this.score+"分"
        );
      }
    }
    //让Plane的原型对象继承Flyer的原型对象
    Object.setPrototypeOf(
      Plane.prototype, Flyer.prototype
    );
    //定义Bee类型描述蜜蜂
      //包括3个属性: name,speed,award
    function Bee(name,speed,award){
      Flyer.apply(this,arguments);
      this.award=award;
    }
    //在Plane的原型对象中添加fly方法
      //输出: "name以时速speed飞行"
    //在Plane的原型对象中添加getAward方法
      //输出: "击落蜜蜂，获得award奖励"
    Bee.prototype={
      getAward:function(){
        console.log(
          "击落蜜蜂，获得"+this.award+"奖励"
        );
      }
    }
    //让Plane的原型对象继承Flyer的原型对象
    Object.setPrototypeOf(
      Bee.prototype, Flyer.prototype
    );
    var f16=new Plane("F16",1000,20);
    var bee=new Bee("小蜜蜂",60,"1 life");
    f16.fly();  f16.getScore();
    bee.fly();  bee.getAward();
    ```
  * 对象的属性
    + 命名属性：自定义的属性
    + 数据属性：实际存储属性值的属性
    + 四大特性：
      1. value: 实际存储属性值
      2. writable：控制是否可写
      3. enumerable：控制能否被遍历（for in）到 -> 但是用.依然可以访问到
      4. configurable：控制以上特性是否可修改，以及是否可以删除属性
      ``` js
      // 如何查看四大特性
      Object.getOwnPropertyDescriptor(
	      obj,"属性名"
      )
      // 如何修改一个属性的四大特性:
      Object.defineProperty(
	      obj, "属性名", {
	        特性: 值,
          ...:...
        }
      )
      /* 第三个参数中，只写需要修改的特性即可
      如果defineProperty修改的属性不存在，会自动创建。
      但是，defineProperty自动创建的属性，四大特性，默认都为false！
      而普通方式添加的属性,四大特性都为true。 */

      // defineProperty问题：一次只能修改一个属性。
      // 解决:
      Object.defineProperties(
	      obj,{
    	        属性名: {
                特性名: 值,
                ...: ...,
              },
              ...
            }
      )

      // 问题: 数据属性对属性的保护比较简单
      // 解决: 用访问器属性自定义保护逻辑
      // 访问器属性: 不直接保存属性值，而是为其它数据属性提供保护的特殊属性
      // 四大特性: 
      get: function(){
        return 受保护的属性的值
      },
      set:function(val){
        //验证通过
        受保护的属性=val
      }
      enumerable: ...
      configurable: ...

      ```
  * 防篡改  
    防止对已经创建好的对象的属性进行增减
    + 防扩展: 禁止向对象中添加新属性
      - 每个对象都有一个内部属性extensible,默认为true，控制能否向对象中添加新属性
      - 设置对象防扩展: Object.preventExtensions(obj)
      - 问题: 不防删除
    + 密封：即防扩展，又设置所有属性的configurable为false！所有属性禁止删除
      - Object.seal(obj)
      - 密封后，属性值，可改
    + 冻结: 所有属性禁止增减，属性值禁止修改
      - 何时使用: 专门定义一个对象，集中保存程序中使用的所有常量属性。
      - Object.freeze(obj)
  * Object api
    + Object.getPrototypeOf(obj)
    + Object.setPrototypeOf(child, father)
    + Object.getOwnPropertyDescriptor()
    + Object.defineProperty()
    + Object.defineProperties()
    + Object.preventExtensions(obj)
    + Object.seal(obj)
    + Object.freeze(obj)
    + Object.create()
      1. 基于一个现有父对象，创建一个新子对象
      2. 继承父对象
      3. 同时扩展子对象的自有新属性
      ``` js
      // 何时使用: 只要基于一个现有父对象，创建子对象时
      // 如何使用: 
      var child = Object.create(father, {
        同defineProperties中第2个参数
      })
      // 如果不扩展新属性，可省略第二个参数
      ```
    + obj.hasOwnProperty('属性名')
    + father.isPrototypeOf(child)

